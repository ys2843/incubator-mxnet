% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mxnet_generated.R
\name{mx.nd.col2im}
\alias{mx.nd.col2im}
\title{Combining the output column matrix of im2col back to image array.}
\arguments{
\item{data}{NDArray-or-Symbol
Input array to combine sliding blocks.}

\item{output.size}{Shape(tuple), required
The spatial dimension of image array: (w,), (h, w) or (d, h, w).}

\item{kernel}{Shape(tuple), required
Sliding kernel size: (w,), (h, w) or (d, h, w).}

\item{stride}{Shape(tuple), optional, default=[]
The stride between adjacent sliding blocks in spatial dimension: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.}

\item{dilate}{Shape(tuple), optional, default=[]
The spacing between adjacent kernel points: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.}

\item{pad}{Shape(tuple), optional, default=[]
The zero-value padding size on both sides of spatial dimension: (w,), (h, w) or (d, h, w). Defaults to no padding.}
}
\value{
out The result mx.ndarray
}
\description{
Like :class:`~mxnet.ndarray.im2col`, this operator is also used in the vanilla convolution
implementation. Despite the name, col2im is not the reverse operation of im2col. Since there
may be overlaps between neighbouring sliding blocks, the column elements cannot be directly
put back into image. Instead, they are accumulated (i.e., summed) in the input image
just like the gradient computation, so col2im is the gradient of im2col and vice versa.
}
\details{
Using the notation in im2col, given an input column array of shape
:math:`(N, C \times  \prod(\text{kernel}), W)`, this operator accumulates the column elements
into output array of shape :math:`(N, C, \text{output_size}[0], \text{output_size}[1], \dots)`.
Only 1-D, 2-D and 3-D of spatial dimension is supported in this operator.



Defined in src/operator/nn/im2col.cc:L182
}
