% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mxnet_generated.R
\name{mx.io.ImageDetRecordIter}
\alias{mx.io.ImageDetRecordIter}
\title{Create iterator for image detection dataset packed in recordio.}
\usage{
mx.io.ImageDetRecordIter(...)
}
\arguments{
\item{path.imglist}{string, optional, default=''
Dataset Param: Path to image list.}

\item{path.imgrec}{string, optional, default='./data/imgrec.rec'
Dataset Param: Path to image record file.}

\item{aug.seq}{string, optional, default='det_aug_default'
Augmentation Param: the augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters. Make sure you don't use normal augmenters for detection tasks.}

\item{label.width}{int, optional, default='-1'
Dataset Param: How many labels for an image, -1 for variable label size.}

\item{preprocess.threads}{int, optional, default='4'
Backend Param: Number of thread to do preprocessing.}

\item{verbose}{boolean, optional, default=1
Auxiliary Param: Whether to output parser information.}

\item{num.parts}{int, optional, default='1'
partition the data into multiple parts}

\item{part.index}{int, optional, default='0'
the index of the part will read}

\item{shuffle.chunk.size}{long (non-negative), optional, default=0
the size(MB) of the shuffle chunk, used with shuffle=True, it can enable global shuffling}

\item{shuffle.chunk.seed}{int, optional, default='0'
the seed for chunk shuffling}

\item{label.pad.width}{int, optional, default='0'
pad output label width if set larger than 0, -1 for auto estimate}

\item{label.pad.value}{float, optional, default=-1
label padding value if enabled}

\item{shuffle}{boolean, optional, default=0
Augmentation Param: Whether to shuffle data.}

\item{seed}{int, optional, default='0'
Augmentation Param: Random Seed.}

\item{batch.size}{int (non-negative), required
Batch size.}

\item{round.batch}{boolean, optional, default=1
Whether to use round robin to handle overflow batch or not.}

\item{prefetch.buffer}{long (non-negative), optional, default=4
Maximum number of batches to prefetch.}

\item{ctx}{{'cpu', 'cpu_pinned', 'gpu'},optional, default='gpu'
Context data loader optimized for. Note that it only indicates the optimization strategy for devices, by no means the prefetcher will load data to GPUs. If ctx is 'cpu_pinned' and device_id is not -1, it will use cpu_pinned(device_id) as ctx}

\item{device.id}{int, optional, default='-1'
The default device id for context. -1 indicate it's on default device}

\item{dtype}{{None, 'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='None'
Output data type. ``None`` means no change.}

\item{resize}{int, optional, default='-1'
Augmentation Param: scale shorter edge to size before applying other augmentations, -1 to disable.}

\item{rand.crop.prob}{float, optional, default=0
Augmentation Param: Probability of random cropping, <= 0 to disable}

\item{min.crop.scales}{tuple of <float>, optional, default=[0]
Augmentation Param: Min crop scales.}

\item{max.crop.scales}{tuple of <float>, optional, default=[1]
Augmentation Param: Max crop scales.}

\item{min.crop.aspect.ratios}{tuple of <float>, optional, default=[1]
Augmentation Param: Min crop aspect ratios.}

\item{max.crop.aspect.ratios}{tuple of <float>, optional, default=[1]
Augmentation Param: Max crop aspect ratios.}

\item{min.crop.overlaps}{tuple of <float>, optional, default=[0]
Augmentation Param: Minimum crop IOU between crop_box and ground-truths.}

\item{max.crop.overlaps}{tuple of <float>, optional, default=[1]
Augmentation Param: Maximum crop IOU between crop_box and ground-truth.}

\item{min.crop.sample.coverages}{tuple of <float>, optional, default=[0]
Augmentation Param: Minimum ratio of intersect/crop_area between crop box and ground-truths.}

\item{max.crop.sample.coverages}{tuple of <float>, optional, default=[1]
Augmentation Param: Maximum ratio of intersect/crop_area between crop box and ground-truths.}

\item{min.crop.object.coverages}{tuple of <float>, optional, default=[0]
Augmentation Param: Minimum ratio of intersect/gt_area between crop box and ground-truths.}

\item{max.crop.object.coverages}{tuple of <float>, optional, default=[1]
Augmentation Param: Maximum ratio of intersect/gt_area between crop box and ground-truths.}

\item{num.crop.sampler}{int, optional, default='1'
Augmentation Param: Number of crop samplers.}

\item{crop.emit.mode}{{'center', 'overlap'},optional, default='center'
Augmentation Param: Emition mode for invalid ground-truths after crop. center: emit if centroid of object is out of crop region; overlap: emit if overlap is less than emit_overlap_thresh.}

\item{emit.overlap.thresh}{float, optional, default=0.300000012
Augmentation Param: Emit overlap thresh for emit mode overlap only.}

\item{max.crop.trials}{Shape(tuple), optional, default=[25]
Augmentation Param: Skip cropping if fail crop trail count exceeds this number.}

\item{rand.pad.prob}{float, optional, default=0
Augmentation Param: Probability for random padding.}

\item{max.pad.scale}{float, optional, default=1
Augmentation Param: Maximum padding scale.}

\item{max.random.hue}{int, optional, default='0'
Augmentation Param: Maximum random value of H channel in HSL color space.}

\item{random.hue.prob}{float, optional, default=0
Augmentation Param: Probability to apply random hue.}

\item{max.random.saturation}{int, optional, default='0'
Augmentation Param: Maximum random value of S channel in HSL color space.}

\item{random.saturation.prob}{float, optional, default=0
Augmentation Param: Probability to apply random saturation.}

\item{max.random.illumination}{int, optional, default='0'
Augmentation Param: Maximum random value of L channel in HSL color space.}

\item{random.illumination.prob}{float, optional, default=0
Augmentation Param: Probability to apply random illumination.}

\item{max.random.contrast}{float, optional, default=0
Augmentation Param: Maximum random value of delta contrast.}

\item{random.contrast.prob}{float, optional, default=0
Augmentation Param: Probability to apply random contrast.}

\item{rand.mirror.prob}{float, optional, default=0
Augmentation Param: Probability to apply horizontal flip aka. mirror.}

\item{fill.value}{int, optional, default='127'
Augmentation Param: Filled color value while padding.}

\item{inter.method}{int, optional, default='1'
Augmentation Param: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.}

\item{data.shape}{Shape(tuple), required
Dataset Param: Shape of each instance generated by the DataIter.}

\item{resize.mode}{{'fit', 'force', 'shrink'},optional, default='force'
Augmentation Param: How image data fit in data_shape. force: force reshape to data_shape regardless of aspect ratio; shrink: ensure each side fit in data_shape, preserve aspect ratio; fit: fit image to data_shape, preserve ratio, will upscale if applicable.}

\item{mean.img}{string, optional, default=''
Augmentation Param: Mean Image to be subtracted.}

\item{mean.r}{float, optional, default=0
Augmentation Param: Mean value on R channel.}

\item{mean.g}{float, optional, default=0
Augmentation Param: Mean value on G channel.}

\item{mean.b}{float, optional, default=0
Augmentation Param: Mean value on B channel.}

\item{mean.a}{float, optional, default=0
Augmentation Param: Mean value on Alpha channel.}

\item{std.r}{float, optional, default=0
Augmentation Param: Standard deviation on R channel.}

\item{std.g}{float, optional, default=0
Augmentation Param: Standard deviation on G channel.}

\item{std.b}{float, optional, default=0
Augmentation Param: Standard deviation on B channel.}

\item{std.a}{float, optional, default=0
Augmentation Param: Standard deviation on Alpha channel.}

\item{scale}{float, optional, default=1
Augmentation Param: Scale in color space.}
}
\value{
iter The result mx.dataiter
}
\description{
Create iterator for image detection dataset packed in recordio.
}
